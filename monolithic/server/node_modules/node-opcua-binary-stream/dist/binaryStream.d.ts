/// <reference types="node" />
import "util";
/**
 * a BinaryStream can be use to perform sequential read or write
 * inside a buffer.
 * The BinaryStream maintains a cursor up to date as the caller
 * operates on the stream using the various read/write methods.
 * It uses the [Little Endian](http://en.wikipedia.org/wiki/Little_endian#Little-endian)
 * convention.
 *
 * data can either be:
 *
 * * a Buffer , in this case the BinaryStream operates on this Buffer
 * * null     , in this case a BinaryStream with 1024 bytes is created
 * * any data , in this case the object is converted into a binary buffer.
 *
 * example:
 *
 *    ``` javascript
 *    var stream = new BinaryStream(32)
 *    ```
 *
 * @class BinaryStream
 * @param {null|Buffer|Number} data
 * @constructor
 *
 *
 *
 */
export declare class BinaryStream {
    _buffer: Buffer;
    length: number;
    constructor(data: undefined | Buffer | number);
    /**
     * set the cursor to the begining of the stream
     * @method BinaryStream.rewind
     * @return null
     */
    rewind(): void;
    /**
     * write a single signed byte (8 bits) to the stream.
     * value must be in the range of [-127,128]
     * @method writeInt8
     * @param value
     */
    writeInt8(value: number): void;
    /**
     * write a single unsigned byte (8 bits) to the stream.
     * @method writeUInt8
     * @param value
     */
    writeUInt8(value: number): void;
    /**
     * write a single 16 bit signed integer to the stream.
     * @method writeInt16
     * @param  value
     */
    writeInt16(value: number): void;
    /**
     * write a single 16 bit unsigned integer to the stream.
     * @method writeUInt16
     * @param  value
     */
    writeUInt16(value: number): void;
    /**
     * write a single 32 bit signed integer to the stream.
     * @method writeInteger
     * @param  value
     */
    writeInteger(value: number): void;
    /**
     * write a single 32 bit unsigned integer to the stream.
     * @method writeUInt32
     * @param value
     */
    writeUInt32(value: number): void;
    /**
     * write a single 32 bit floating number to the stream.
     * @method writeFloat
     * @param value
     */
    writeFloat(value: number): void;
    /**
     * write a single 64 bit floating number to the stream.
     * @method writeDouble
     * @param value
     */
    writeDouble(value: number): void;
    /**
     * @method writeArrayBuffer
     * @param arrayBuf {ArrayBuffer}
     * @param offset   {Number}
     * @param length   {Number}
     */
    writeArrayBuffer(arrayBuf: ArrayBuffer, offset?: number, length?: number): void;
    /**
     * read a single signed byte  (8 bits) from the stream.
     * @method readByte
     * @return {Number}
     */
    readByte(): number;
    readInt8(): number;
    /**
     * read a single unsigned byte (8 bits) from the stream.
     * @method readUInt8
     * @return {Number}
     */
    readUInt8(): number;
    /**
     * read a single signed 16-bit integer from the stream.
     * @method readInt16
     * @return {Number}
     */
    readInt16(): number;
    /**
     * read a single unsigned 16-bit integer from the stream.
     * @method readUInt16
     * @return {Number}  q
     */
    readUInt16(): number;
    /**
     * read a single signed 32-bit integer from the stream.
     * @method readInteger
     * @return {Number}
     */
    readInteger(): number;
    /**
     * read a single unsigned 32-bit integer from the stream.
     * @method readUInt32
     * @return {number} the value read from the stream
     */
    readUInt32(): number;
    /**
     * read a single  32-bit floating point number from the stream.
     * @method readFloat
     * @return  the value read from the stream
     */
    readFloat(): number;
    /**
     * read a single 64-bit floating point number from the stream.
     * @method readDouble
     * @return  the value read from the stream
     */
    readDouble(): number;
    /**
     * write a byte stream to the stream.
     * The method writes the length of the byte array into the stream as a 32 bits integer before the byte stream.
     *
     * @method writeByteStream
     * @param {Buffer} buf the    buffer to write.
     *   the buffer buf.length the buffer to write
     */
    writeByteStream(buf: Buffer): void;
    writeString(value: string): void;
    /**
     * @method readArrayBuffer
     * @param length
     * @returns {Uint8Array}
     */
    readArrayBuffer(length: number): Uint8Array;
    /**
     * read a byte stream to the stream.
     * The method reads the length of the byte array from the stream as a 32 bits integer before reading the byte stream.
     *
     * @method readByteStream
     * @return {Buffer}
     */
    readByteStream(): Buffer | null;
    readString(): string | null;
}
/**
 * a BinaryStreamSizeCalculator can be used to quickly evaluate the required size
 * of a buffer by performing the same sequence of write operation.
 *
 * a BinaryStreamSizeCalculator has the same writeXXX methods as the BinaryStream stream
 * object.
 *
 * @class BinaryStreamSizeCalculator
 * @extends BinaryStream
 * @constructor
 *
 */
export declare class BinaryStreamSizeCalculator {
    length: number;
    constructor();
    rewind(): void;
    writeInt8(value: number): void;
    writeUInt8(value: number): void;
    writeInt16(value: number): void;
    writeInteger(value: number): void;
    writeUInt32(value: number): void;
    writeUInt16(value: number): void;
    writeFloat(value: number): void;
    writeDouble(value: number): void;
    writeArrayBuffer(arrayBuf: ArrayBuffer, offset: number, byteLength: number): void;
    writeByteStream(buf: Buffer): void;
    writeString(str: string): void;
}
